<template name="game">
 		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>

<div id="game">
</div>

	<script>
/*
Card size 63mm x 88mm x 0.305mm (online)

TODO: Measure acutal height of 100 cards stack.
*/
		THREE.ImageUtils.crossOrigin = '';

		var cube;
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

		var renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setClearColor( 0x77C73E );

		var $div = $('#game');

		if ($div.children().length === 0 ) {
			$div.append( renderer.domElement );
		}

		var geometry = new THREE.BoxGeometry( 62, 88, 0.4 );

  		var count = 0;
		var mouse = new THREE.Vector2();
		var INTERSECTED;
		var raycaster = new THREE.Raycaster();



var query = DeckCollection.find({user: Meteor.userId()});
var handle = query.observeChanges({
  added: function (id, card) {

  		count++;

    console.log("Adding: "+card.name);

		// material
		var material = new THREE.MeshLambertMaterial({
			map: THREE.ImageUtils.loadTexture('http://api.mtgdb.info/content/card_images/'+card.id+'.jpeg')
		});

		cube = new THREE.Mesh( geometry, material );
//		cube.rotation.x = Random.fraction();
//		cube.rotation.y = 0.03;
		cube.rotation.z = Random.fraction()-0.5;	

		cube.position.x = Random.fraction()*500-250;
		cube.position.y = Random.fraction()*200-100;
		cube.position.z = count*.01;

		scene.add( cube );
  }
});

		var light = new THREE.AmbientLight( 0xffffff ); // soft white light
		scene.add( light );

		camera.position.z = 200;

		document.addEventListener( 'mousemove', onDocumentMouseMove, false );

		function animate() {

			requestAnimationFrame( animate );

			render();
		}

		animate();

		function onDocumentMouseMove( event ) {

			event.preventDefault();

			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

		}

			function render() {

/*				theta += 0.1;

				camera.position.x = radius * Math.sin( THREE.Math.degToRad( theta ) );
				camera.position.y = radius * Math.sin( THREE.Math.degToRad( theta ) );
				camera.position.z = radius * Math.cos( THREE.Math.degToRad( theta ) );
				camera.lookAt( scene.position );

				camera.updateMatrixWorld();
*/
				// find intersections

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( scene.children );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0x555555 );

					}

				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

				}

				renderer.render( scene, camera );

			}
	</script>
</template>
