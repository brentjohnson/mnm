<template name="game">
 		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>

<div id="game">
</div>

	<script>

	Physijs.scripts.worker = '/js/physijs_worker.js';
	Physijs.scripts.ammo = '/js/ammo.js';

/*
Card size 63mm x 88mm x 0.305mm (online)

TODO: Measure acutal height of 100 cards stack.
*/
THREE.ImageUtils.crossOrigin = '';

var cube;
var scene = new Physijs.Scene();
scene.setGravity(new THREE.Vector3( 0, -98, 0 ))
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

var renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x77C73E);

var $div = $('#game');

if ($div.children().length === 0) {
    $div.append(renderer.domElement);
}

var geometry = new THREE.BoxGeometry(62, 88, 1);

var count = 0;
var mouse = new THREE.Vector2();
var INTERSECTED;
var raycaster = new THREE.Raycaster();
var black = new THREE.MeshLambertMaterial({ color: 0x000000 });

/*
		ground_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'images/rocks.jpg' ) }),
			.8, // high friction
			.4 // low restitution
		);
		ground_material.map.wrapS = ground_material.map.wrapT = THREE.RepeatWrapping;
		ground_material.map.repeat.set( 2.5, 2.5 );
*/		

var query = DeckCollection.find({
    user: Meteor.userId()
});
var handle = query.observeChanges({
    added: function(id, card) {

        count++;

        console.log("Adding: " + card.name);

        // material

        var materials = [
            black,
            black,
            black,
            black,
            new THREE.MeshLambertMaterial({
                map: THREE.ImageUtils.loadTexture('http://api.mtgdb.info/content/card_images/' + card.id + '.jpeg')
            }),
            new THREE.MeshLambertMaterial({
                map: THREE.ImageUtils.loadTexture('/img/back.jpeg')
            })
        ];

        cube = new Physijs.BoxMesh(geometry, new THREE.MeshFaceMaterial(materials));

    	cube.rotation.x = -0.1;

        if (count % 10 === 0) {
            cube.rotation.y = Math.PI;
        }
        cube.rotation.z = Random.fraction() - 0.5;

        cube.position.x = Random.fraction() * 500 - 250;
        cube.position.y = Random.fraction() * 200 - 100;
        cube.position.z = count * 0.4;

/* DOESN'T WORK 
        cube.setAngularVelocity(
//        	{x: (Random.fraction() - 0.5)*100, y: (Random.fraction() - 0.5)*100, z: (Random.fraction() - 0.5)*100}
        	{x: 1, y: 2, z: 3}
        );
        cube.__dirtyRotation = true;
*/
        scene.add(cube);
    }
});


var light = new THREE.AmbientLight(0xffffff);
scene.add(light);

camera.position.z = 400;

document.addEventListener('mousemove', onDocumentMouseMove, false);




function animate() {

    scene.simulate();
        renderer.render(scene, camera); //render();
    requestAnimationFrame(animate);
}

animate();

		ground = new Physijs.BoxMesh(
			new THREE.BoxGeometry(1000, 100, 1000),
			//new THREE.PlaneGeometry(50, 50),
			black,
			0 // mass
		);
//		ground.receiveShadow = true;
		ground.position.y = -200;
//		ground.rotation.x = Math.PI;
		scene.add( ground );

function onDocumentMouseMove(event) {

    event.preventDefault();

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

}

function render() {

    // find intersections

    raycaster.setFromCamera(mouse, camera);

    var intersects = raycaster.intersectObjects(scene.children);

    if (intersects.length > 0) {

        if (INTERSECTED != intersects[0]) {

            if (INTERSECTED) INTERSECTED.object.material.materials[INTERSECTED.face.materialIndex].emissive.setHex(INTERSECTED.currentHex);

            INTERSECTED = intersects[0];
            INTERSECTED.currentHex = INTERSECTED.object.material.materials[INTERSECTED.face.materialIndex].emissive.getHex();
            INTERSECTED.object.material.materials[INTERSECTED.face.materialIndex].emissive.setHex(0x555555);

        }

    } else {

        if (INTERSECTED) INTERSECTED.object.material.materials[INTERSECTED.face.materialIndex].emissive.setHex(INTERSECTED.currentHex);

        INTERSECTED = null;

    }

    renderer.render(scene, camera);

}
	</script>
</template>
